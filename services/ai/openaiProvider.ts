// =================================================================
// OpenAI Direct Provider - 最新モデル先行アクセス対応
// 2025年最新API対応 (GPT-4.1, o3-mini, GPT-image-1)
// =================================================================

import { 
  AIProvider,
  AIProviderType,
  AIProviderConfig,
  TextGenerationRequest,
  ImageGenerationRequest,
  VideoAnalysisRequest,
  AIProviderError,
  AIProviderConnectionError,
  AIProviderConfigError,
  AIProviderRateLimitError,
  AIProviderQuotaExceededError
} from './aiProviderInterface';

import { getAvailableModels } from './modelRegistry';

// OpenAI SDK インターフェース
interface OpenAIClient {
  chat: {
    completions: {
      create: (params: any) => Promise<any>;
    };
  };
  images: {
    generate: (params: any) => Promise<any>;
  };
  models: {
    list: () => Promise<any>;
  };
}

export class OpenAIProvider implements AIProvider {
  name: AIProviderType = 'openai';
  private client: OpenAIClient;
  private config: AIProviderConfig;

  constructor(config: AIProviderConfig) {
    this.config = config;

    if (!config.apiKey) {
      throw new AIProviderConfigError(
        'OpenAI API key is required',
        'openai'
      );
    }

    try {
      this.client = this.createOpenAIClient(config);
    } catch (error) {
      throw new AIProviderConnectionError(
        `Failed to initialize OpenAI client: ${error.message}`,
        'openai',
        error as Error
      );
    }
  }

  async generateText(request: TextGenerationRequest): Promise<string> {
    try {
      const modelId = request.model || this.config.models.textGeneration || 'gpt-4o';
      
      const response = await this.client.chat.completions.create({
        model: modelId,
        messages: [
          ...(request.systemPrompt ? [{ role: 'system', content: request.systemPrompt }] : []),
          { role: 'user', content: request.prompt }
        ],
        temperature: request.temperature || 0.7,
        max_tokens: request.maxTokens || 4096,
        top_p: 1,
        frequency_penalty: 0,
        presence_penalty: 0,
      });

      if (!response.choices || response.choices.length === 0) {
        throw new AIProviderError(
          'No response generated by OpenAI',
          'openai'
        );
      }

      return response.choices[0].message.content || '';
    } catch (error) {
      throw this.handleOpenAIError(error, 'Text Generation');
    }
  }

  async generateImage(request: ImageGenerationRequest): Promise<string> {
    try {
      const modelId = request.model || this.config.models.imageGeneration || 'dall-e-3';
      
      const response = await this.client.images.generate({
        model: modelId,
        prompt: request.prompt,
        size: request.size || '1024x1024',
        quality: request.quality || 'standard',
        style: request.style || 'natural',
        n: request.n || 1,
        response_format: 'b64_json'
      });

      if (!response.data || response.data.length === 0) {
        throw new AIProviderError(
          'No image generated by OpenAI',
          'openai'
        );
      }

      const b64Data = response.data[0].b64_json;
      return `data:image/png;base64,${b64Data}`;
    } catch (error) {
      throw this.handleOpenAIError(error, 'Image Generation');
    }
  }

  async analyzeVideo(request: VideoAnalysisRequest): Promise<string> {
    try {
      const modelId = request.model || this.config.models.videoAnalysis || 'gpt-4o';
      
      // GPT-4o Vision を使用してビデオフレーム分析
      const response = await this.client.chat.completions.create({
        model: modelId,
        messages: [{
          role: 'user',
          content: [
            { type: 'text', text: request.prompt },
            { 
              type: 'image_url', 
              image_url: { 
                url: request.videoData,
                detail: 'high'
              } 
            }
          ]
        }],
        temperature: 0.3,
        max_tokens: 4096,
      });

      if (!response.choices || response.choices.length === 0) {
        throw new AIProviderError(
          'No analysis generated by OpenAI',
          'openai'
        );
      }

      return response.choices[0].message.content || '';
    } catch (error) {
      throw this.handleOpenAIError(error, 'Video Analysis');
    }
  }

  async validateConfig(config: AIProviderConfig): Promise<boolean> {
    try {
      if (!config.apiKey) {
        return false;
      }

      // 軽量なテストリクエストで設定を検証
      const testClient = this.createOpenAIClient(config);
      
      await testClient.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{ role: 'user', content: 'test' }],
        max_tokens: 1
      });

      return true;
    } catch (error) {
      return false;
    }
  }

  async getAvailableModels(): Promise<{ [key: string]: string[] }> {
    try {
      // OpenAI APIから直接利用可能なモデルを取得
      const response = await this.client.models.list();
      const allModels = response.data.map((model: any) => model.id);
      
      // モデルをカテゴリ別に分類
      const textModels = allModels.filter((id: string) => 
        id.includes('gpt') || id.includes('o1') || id.includes('o3')
      );
      
      const imageModels = allModels.filter((id: string) => 
        id.includes('dall-e') || id.includes('gpt-image')
      );
      
      // ビデオ分析はVision対応モデル
      const videoModels = allModels.filter((id: string) => 
        id.includes('gpt-4o') || id.includes('gpt-4-vision')
      );

      return {
        textGeneration: textModels,
        imageGeneration: imageModels,
        videoAnalysis: videoModels,
      };
    } catch (error) {
      // フォールバック: レジストリからの固定リスト
      const textModels = getAvailableModels('openai', 'text').map(m => m.id);
      const imageModels = getAvailableModels('openai', 'image').map(m => m.id);
      const videoModels = getAvailableModels('openai', 'video').map(m => m.id);

      return {
        textGeneration: textModels,
        imageGeneration: imageModels,
        videoAnalysis: videoModels,
      };
    }
  }

  async estimateCost(request: any): Promise<number> {
    // OpenAI Direct API 価格計算 (2025年価格)
    const pricing = {
      'gpt-4.1': { input: 0.075, output: 0.15 },
      'gpt-4o': { input: 0.025, output: 0.10 },
      'gpt-4o-mini': { input: 0.0008, output: 0.0032 },
      'o3-mini': { input: 0.011, output: 0.044 },
      'o1-mini': { input: 0.030, output: 0.120 },
      'gpt-image-1': { image: 0.08 },
      'dall-e-3': { image: 0.04 },
    };

    const modelId = request.model || 'gpt-4o';
    const modelPricing = pricing[modelId];
    
    if (!modelPricing) {
      return 0.01; // Default small cost
    }

    if (request.task === 'text') {
      const inputTokens = Math.ceil((request.prompt?.length || 100) / 4);
      const outputTokens = request.maxTokens || 1000;
      return (inputTokens * modelPricing.input + outputTokens * modelPricing.output) / 1000000;
    } else if (request.task === 'image') {
      return modelPricing.image || 0.04;
    }

    return 0.01;
  }

  // OpenAI クライアント作成
  private createOpenAIClient(config: AIProviderConfig): OpenAIClient {
    // 実際の実装では適切なOpenAI SDKを使用
    return {
      chat: {
        completions: {
          create: async (params: any) => {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${config.apiKey}`,
                ...(config.organization && { 'OpenAI-Organization': config.organization })
              },
              body: JSON.stringify(params)
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(`OpenAI API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
            }

            return await response.json();
          }
        }
      },
      images: {
        generate: async (params: any) => {
          const response = await fetch('https://api.openai.com/v1/images/generations', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${config.apiKey}`,
              ...(config.organization && { 'OpenAI-Organization': config.organization })
            },
            body: JSON.stringify(params)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(`OpenAI Image API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
          }

          return await response.json();
        }
      },
      models: {
        list: async () => {
          const response = await fetch('https://api.openai.com/v1/models', {
            headers: {
              'Authorization': `Bearer ${config.apiKey}`,
              ...(config.organization && { 'OpenAI-Organization': config.organization })
            }
          });

          if (!response.ok) {
            throw new Error(`OpenAI Models API error: ${response.status} ${response.statusText}`);
          }

          return await response.json();
        }
      }
    };
  }

  // OpenAI固有エラーハンドリング
  private handleOpenAIError(error: unknown, context: string): AIProviderError {
    if (error instanceof AIProviderError) {
      return error;
    }

    if (error instanceof Error) {
      const message = error.message.toLowerCase();
      
      if (message.includes('unauthorized') || message.includes('invalid api key')) {
        return new AIProviderConfigError(
          'Invalid OpenAI API key. Please check your configuration.',
          'openai',
          error
        );
      }
      
      if (message.includes('quota') || message.includes('billing')) {
        return new AIProviderQuotaExceededError(
          'OpenAI quota exceeded or billing issue. Please check your account.',
          'openai',
          error
        );
      }
      
      if (message.includes('rate limit') || message.includes('429')) {
        return new AIProviderRateLimitError(
          'OpenAI rate limit exceeded. Please try again later.',
          'openai',
          error
        );
      }
      
      if (message.includes('model') && message.includes('not found')) {
        return new AIProviderConfigError(
          'Requested OpenAI model not found or not accessible.',
          'openai',
          error
        );
      }
      
      return new AIProviderError(
        `OpenAI ${context} error: ${error.message}`,
        'openai',
        'UNKNOWN_ERROR',
        error
      );
    }

    return new AIProviderError(
      `OpenAI ${context}: Unknown error occurred`,
      'openai',
      'UNKNOWN_ERROR'
    );
  }
}