// =================================================================
// Claude Provider - コーディング・推論特化プロバイダー
// 2025年最新対応 (Claude 3.7 Sonnet, Computer Use)
// =================================================================

import { 
  AIProvider,
  AIProviderType,
  AIProviderConfig,
  TextGenerationRequest,
  ImageGenerationRequest,
  VideoAnalysisRequest,
  AIProviderError,
  AIProviderConnectionError,
  AIProviderConfigError,
  AIProviderRateLimitError,
  AIProviderQuotaExceededError
} from './aiProviderInterface';

import { getAvailableModels } from './modelRegistry';

// Anthropic SDK インターフェース
interface AnthropicClient {
  messages: {
    create: (params: any) => Promise<any>;
  };
}

export class ClaudeProvider implements AIProvider {
  name: AIProviderType = 'claude';
  private client: AnthropicClient;
  private config: AIProviderConfig;

  constructor(config: AIProviderConfig) {
    this.config = config;

    if (!config.apiKey) {
      throw new AIProviderConfigError(
        'Claude API key is required',
        'claude'
      );
    }

    try {
      this.client = this.createClaudeClient(config);
    } catch (error) {
      throw new AIProviderConnectionError(
        `Failed to initialize Claude client: ${error.message}`,
        'claude',
        error as Error
      );
    }
  }

  async generateText(request: TextGenerationRequest): Promise<string> {
    try {
      const modelId = request.model || this.config.models.textGeneration || 'claude-3.5-sonnet';
      
      const response = await this.client.messages.create({
        model: modelId,
        max_tokens: request.maxTokens || 4096,
        temperature: request.temperature || 0.7,
        system: request.systemPrompt,
        messages: [
          { role: 'user', content: request.prompt }
        ],
      });

      if (!response.content || response.content.length === 0) {
        throw new AIProviderError(
          'No response generated by Claude',
          'claude'
        );
      }

      // Claude 3.7のハイブリッド推論モードでは、thinking processも含まれる場合がある
      const textContent = response.content
        .filter((item: any) => item.type === 'text')
        .map((item: any) => item.text)
        .join('\n');

      return textContent || '';
    } catch (error) {
      throw this.handleClaudeError(error, 'Text Generation');
    }
  }

  async generateImage(request: ImageGenerationRequest): Promise<string> {
    // Claudeは画像生成未対応
    throw new AIProviderError(
      'Claude does not support native image generation. Please use another provider for image generation.',
      'claude',
      'UNSUPPORTED_OPERATION'
    );
  }

  async analyzeVideo(request: VideoAnalysisRequest): Promise<string> {
    try {
      const modelId = request.model || this.config.models.videoAnalysis || 'claude-3.7-sonnet';
      
      // Claude 3.7 Sonnetでの動画/画像分析
      const response = await this.client.messages.create({
        model: modelId,
        max_tokens: 4096,
        temperature: 0.3,
        messages: [{
          role: 'user',
          content: [
            { type: 'text', text: request.prompt },
            { 
              type: 'image', 
              source: { 
                type: 'base64', 
                media_type: this.detectMediaType(request.videoData),
                data: request.videoData.split(',')[1] // Remove data URL prefix
              } 
            }
          ]
        }],
      });

      if (!response.content || response.content.length === 0) {
        throw new AIProviderError(
          'No analysis generated by Claude',
          'claude'
        );
      }

      const textContent = response.content
        .filter((item: any) => item.type === 'text')
        .map((item: any) => item.text)
        .join('\n');

      return textContent || '';
    } catch (error) {
      throw this.handleClaudeError(error, 'Video Analysis');
    }
  }

  async validateConfig(config: AIProviderConfig): Promise<boolean> {
    try {
      if (!config.apiKey) {
        return false;
      }

      // 軽量なテストリクエストで設定を検証
      const testClient = this.createClaudeClient(config);
      
      await testClient.messages.create({
        model: 'claude-3.5-haiku',
        max_tokens: 1,
        messages: [{ role: 'user', content: 'test' }]
      });

      return true;
    } catch (error) {
      return false;
    }
  }

  async getAvailableModels(): Promise<{ [key: string]: string[] }> {
    try {
      const textModels = getAvailableModels('claude', 'text').map(m => m.id);
      const imageModels = []; // Claudeは画像生成未対応
      const videoModels = getAvailableModels('claude', 'video').map(m => m.id);

      return {
        textGeneration: textModels,
        imageGeneration: imageModels,
        videoAnalysis: videoModels,
      };
    } catch (error) {
      return {
        textGeneration: ['claude-3.5-sonnet', 'claude-3.5-haiku'],
        imageGeneration: [],
        videoAnalysis: ['claude-3.7-sonnet', 'claude-3.5-sonnet'],
      };
    }
  }

  async estimateCost(request: any): Promise<number> {
    // Claude 価格計算 (2025年価格)
    const pricing = {
      'claude-3.7-sonnet': { input: 3.0, output: 15.0 },
      'claude-3.5-sonnet': { input: 3.0, output: 15.0 },
      'claude-3.5-haiku': { input: 0.8, output: 4.0 },
    };

    const modelId = request.model || 'claude-3.5-sonnet';
    const modelPricing = pricing[modelId];
    
    if (!modelPricing) {
      return 0.05; // Default cost
    }

    if (request.task === 'text' || request.task === 'video') {
      const inputTokens = Math.ceil((request.prompt?.length || 100) / 4);
      const outputTokens = request.maxTokens || 1000;
      return (inputTokens * modelPricing.input + outputTokens * modelPricing.output) / 1000000;
    }

    return 0.05;
  }

  // Claude クライアント作成
  private createClaudeClient(config: AIProviderConfig): AnthropicClient {
    return {
      messages: {
        create: async (params: any) => {
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-api-key': config.apiKey,
              'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(params)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(`Claude API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
          }

          return await response.json();
        }
      }
    };
  }

  // メディアタイプ検出
  private detectMediaType(dataUrl: string): string {
    if (dataUrl.startsWith('data:video/')) {
      const match = dataUrl.match(/data:(video\/[^;]+)/);
      return match ? match[1] : 'video/mp4';
    } else if (dataUrl.startsWith('data:image/')) {
      const match = dataUrl.match(/data:(image\/[^;]+)/);
      return match ? match[1] : 'image/jpeg';
    }
    
    // デフォルトは画像として扱う
    return 'image/jpeg';
  }

  // Claude固有エラーハンドリング
  private handleClaudeError(error: unknown, context: string): AIProviderError {
    if (error instanceof AIProviderError) {
      return error;
    }

    if (error instanceof Error) {
      const message = error.message.toLowerCase();
      
      if (message.includes('unauthorized') || message.includes('invalid api key')) {
        return new AIProviderConfigError(
          'Invalid Claude API key. Please check your configuration.',
          'claude',
          error
        );
      }
      
      if (message.includes('quota') || message.includes('credit')) {
        return new AIProviderQuotaExceededError(
          'Claude quota exceeded or credit balance insufficient.',
          'claude',
          error
        );
      }
      
      if (message.includes('rate limit') || message.includes('429')) {
        return new AIProviderRateLimitError(
          'Claude rate limit exceeded. Please try again later.',
          'claude',
          error
        );
      }
      
      if (message.includes('model') && message.includes('not found')) {
        return new AIProviderConfigError(
          'Requested Claude model not found or not accessible.',
          'claude',
          error
        );
      }
      
      if (message.includes('content')) {
        return new AIProviderError(
          'Claude content policy violation or invalid content format.',
          'claude',
          'CONTENT_ERROR',
          error
        );
      }
      
      return new AIProviderError(
        `Claude ${context} error: ${error.message}`,
        'claude',
        'UNKNOWN_ERROR',
        error
      );
    }

    return new AIProviderError(
      `Claude ${context}: Unknown error occurred`,
      'claude',
      'UNKNOWN_ERROR'
    );
  }

  // Claude 3.7の特殊機能: ハイブリッド推論モード
  async generateWithThinking(
    prompt: string,
    options?: {
      enableThinking?: boolean;
      thinkingBudget?: 'low' | 'medium' | 'high';
      systemPrompt?: string;
    }
  ): Promise<{ result: string; thinking?: string }> {
    try {
      const response = await this.client.messages.create({
        model: 'claude-3.7-sonnet',
        max_tokens: 4096,
        temperature: 0.7,
        system: options?.systemPrompt,
        messages: [
          { 
            role: 'user', 
            content: options?.enableThinking 
              ? `<thinking_mode>${options.thinkingBudget || 'medium'}</thinking_mode>\n${prompt}`
              : prompt
          }
        ],
      });

      if (!response.content || response.content.length === 0) {
        throw new AIProviderError(
          'No response generated by Claude',
          'claude'
        );
      }

      // thinking processとresultを分離
      let thinking = '';
      let result = '';

      for (const item of response.content) {
        if (item.type === 'text') {
          const text = item.text;
          
          // thinking processの抽出
          const thinkingMatch = text.match(/<thinking>(.*?)<\/thinking>/s);
          if (thinkingMatch) {
            thinking = thinkingMatch[1].trim();
            result = text.replace(/<thinking>.*?<\/thinking>/s, '').trim();
          } else {
            result = text;
          }
        }
      }

      return {
        result,
        ...(thinking && { thinking })
      };
    } catch (error) {
      throw this.handleClaudeError(error, 'Thinking Generation');
    }
  }
}