import { Presentation, ExportResult } from '../../types';
import { saveAs } from 'file-saver';
import JSZip from 'jszip';
import { 
  createVersionMetadata, 
  getVersionString, 
  APP_VERSION, 
  CURRENT_FILE_FORMAT_VERSION 
} from '../../utils/versionManager';
import { checkAndUpgradePresentation, checkImportCompatibility } from '../storageService';
import {
  generateFilename,
  createErrorResult,
  createSuccessResult,
  validatePresentation
} from './exportUtils';

// =================================================================
// Project Export Service - SlideMaster project format export/import
// =================================================================

/**
 * Export presentation as SlideMaster project file (Original ZIP format)
 */
export const exportProject = async (presentation: Presentation): Promise<ExportResult> => {
  try {
    validatePresentation(presentation);

    const zip = new JSZip();
    
    // Add presentation data
    zip.file('presentation.json', JSON.stringify(presentation, null, 2));
    
    // Add slide sources if they exist
    if (presentation.sources && presentation.sources.length > 0) {
      const sourcesFolder = zip.folder('sources');
      if (sourcesFolder) {
        presentation.sources.forEach((source, index) => {
          const sourceFilename = `${source.type}_${index + 1}_${source.name.replace(/[<>:"/\\|?*]/g, '_')}.md`;
          sourcesFolder.file(sourceFilename, source.content);
          
          // Add metadata for the source
          const sourceMetadata = {
            id: source.id,
            type: source.type,
            name: source.name,
            createdAt: source.createdAt,
            metadata: source.metadata || {}
          };
          sourcesFolder.file(`${sourceFilename}.json`, JSON.stringify(sourceMetadata, null, 2));
        });
      }
    }
    
    // Add generation history if it exists
    if (presentation.generationHistory && presentation.generationHistory.length > 0) {
      zip.file('generation_history.json', JSON.stringify(presentation.generationHistory, null, 2));
    }
    
    // Add metadata with version information
    const metadata = {
      name: presentation.title,
      description: presentation.description,
      exportedWith: APP_VERSION,
      fileFormatVersion: getVersionString(CURRENT_FILE_FORMAT_VERSION),
      originalVersion: presentation.version ? getVersionString(presentation.version) : 'Unknown',
      createdAt: presentation.createdAt,
      updatedAt: presentation.updatedAt,
      slides: presentation.slides.length,
      theme: presentation.theme,
      compatibilityNotes: presentation.compatibilityNotes || [],
    };
    zip.file('metadata.json', JSON.stringify(metadata, null, 2));

    // Add README
    const readme = `# ${presentation.title}

## Description
${presentation.description}

## Project Details
- Created: ${new Date(presentation.createdAt).toLocaleDateString()}
- Last Updated: ${new Date(presentation.updatedAt).toLocaleDateString()}
- Total Slides: ${presentation.slides.length}
- Theme: ${presentation.theme}

## How to Import
1. Open SlideMaster
2. Click "Resume from Project"
3. Select this ZIP file

Generated by SlideMaster
`;
    zip.file('README.md', readme);

    const blob = await zip.generateAsync({ type: 'blob' });
    const filename = generateFilename(presentation, 'zip');
    saveAs(blob, filename);

    return createSuccessResult(filename, 'zip');
  } catch (error) {
    console.error('Project export error:', error);
    return createErrorResult(error);
  }
};

/**
 * Import presentation from SlideMaster project file (Original ZIP format)
 */
export const importProject = async (file: File): Promise<{ 
  success: boolean; 
  presentation?: Presentation; 
  error?: string;
}> => {
  try {
    if (!file.name.endsWith('.zip')) {
      throw new Error('プロジェクトファイルは.zip形式である必要があります');
    }

    const zip = new JSZip();
    const zipContent = await zip.loadAsync(file);

    // Check if it's a valid SlideMaster project
    const presentationFile = zipContent.file('presentation.json');
    if (!presentationFile) {
      throw new Error('有効なSlideMasterプロジェクトファイルではありません（presentation.jsonが見つかりません）');
    }

    // Parse presentation data
    const presentationData = await presentationFile.async('text');
    const rawPresentation = JSON.parse(presentationData);

    // Check metadata for version information
    let metadata = null;
    const metadataFile = zipContent.file('metadata.json');
    if (metadataFile) {
      const metadataText = await metadataFile.async('text');
      metadata = JSON.parse(metadataText);
    }

    // Check version compatibility before processing
    const compatibility = checkImportCompatibility(rawPresentation);
    
    if (!compatibility.canImport) {
      if (compatibility.requiresUpgrade) {
        throw new Error(
          'このファイルは新しいバージョンで作成されています。アプリケーションを更新してください。'
        );
      } else {
        throw new Error(
          `互換性のないファイル形式です: ${compatibility.warnings.join(', ')}`
        );
      }
    }

    // Process and upgrade presentation if necessary
    const presentation = await checkAndUpgradePresentation(rawPresentation);

    // Log compatibility warnings if any
    if (compatibility.warnings.length > 0) {
      console.warn('Import warnings:', compatibility.warnings);
    }

    // Update timestamps
    presentation.updatedAt = new Date();

    // Generate new ID to avoid conflicts
    presentation.id = `presentation-${Date.now()}`;

    // Add import metadata
    if (!presentation.compatibilityNotes) {
      presentation.compatibilityNotes = [];
    }
    presentation.compatibilityNotes.push(
      `Imported from project file on ${new Date().toISOString()}`,
      ...(metadata ? [`Original version: ${metadata.originalVersion || 'Unknown'}`] : []),
      ...(compatibility.warnings.length > 0 ? [`Warnings: ${compatibility.warnings.join(', ')}`] : [])
    );

    return {
      success: true,
      presentation,
    };
  } catch (error) {
    console.error('Project import error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'プロジェクトファイルのインポートに失敗しました',
    };
  }
};

/**
 * Import presentation from legacy JSON format
 */
export const importProjectLegacy = async (file: File): Promise<{ 
  success: boolean; 
  presentation?: Presentation; 
  error?: string;
  warnings?: string[];
}> => {
  try {
    if (!file) {
      throw new Error('No file provided');
    }

    if (file.type !== 'application/json') {
      throw new Error('Invalid file type. Please select a JSON file.');
    }

    // Read file content
    const content = await new Promise<string>((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        if (e.target?.result) {
          resolve(e.target.result as string);
        } else {
          reject(new Error('Failed to read file'));
        }
      };
      reader.onerror = () => reject(new Error('Error reading file'));
      reader.readAsText(file);
    });

    // Parse JSON
    let importedData: any;
    try {
      importedData = JSON.parse(content);
    } catch (parseError) {
      throw new Error('Invalid JSON file. The file appears to be corrupted.');
    }

    // Check compatibility
    const compatibilityCheck = checkImportCompatibility(importedData);
    if (!compatibilityCheck.compatible) {
      throw new Error(`Incompatible file format: ${compatibilityCheck.reason}`);
    }

    // Upgrade if necessary
    const { presentation: upgradedPresentation, upgraded, warnings } = checkAndUpgradePresentation(importedData);

    // Validate the imported presentation
    if (!upgradedPresentation || typeof upgradedPresentation !== 'object') {
      throw new Error('Invalid presentation data structure');
    }

    if (!upgradedPresentation.id) {
      upgradedPresentation.id = `imported-${Date.now()}`;
    }

    if (!upgradedPresentation.title) {
      upgradedPresentation.title = file.name.replace(/\.[^/.]+$/, '') || 'Imported Presentation';
    }

    if (!upgradedPresentation.slides || !Array.isArray(upgradedPresentation.slides)) {
      throw new Error('No valid slides found in the imported file');
    }

    // Update import metadata
    const versionMetadata = createVersionMetadata();
    upgradedPresentation.updatedAt = new Date();
    upgradedPresentation.lastModifiedWith = versionMetadata.lastModifiedWith;
    upgradedPresentation.importedAt = new Date();
    upgradedPresentation.importedFrom = file.name;

    return {
      success: true,
      presentation: upgradedPresentation as Presentation,
      warnings: warnings.length > 0 ? warnings : undefined
    };

  } catch (error) {
    console.error('Project import error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred during import'
    };
  }
};

/**
 * Export presentation with backup metadata
 */
export const exportProjectWithBackup = async (
  presentation: Presentation,
  includeHistory: boolean = true
): Promise<ExportResult> => {
  try {
    validatePresentation(presentation);

    // Create comprehensive backup data
    const versionMetadata = createVersionMetadata();
    const backupData = {
      ...presentation,
      backup: {
        createdAt: new Date().toISOString(),
        createdWith: versionMetadata.createdWith,
        appVersion: APP_VERSION,
        fileFormatVersion: CURRENT_FILE_FORMAT_VERSION,
        platform: navigator.platform,
        userAgent: navigator.userAgent,
      },
      metadata: {
        originalCreatedAt: presentation.createdAt,
        originalUpdatedAt: presentation.updatedAt,
        exportCount: (presentation as any).exportCount ? (presentation as any).exportCount + 1 : 1,
        slideCount: presentation.slides.length,
        layerCount: presentation.slides.reduce((total, slide) => total + slide.layers.length, 0),
        hasImages: presentation.slides.some(slide => 
          slide.layers.some(layer => layer.type === 'image')
        ),
        hasVideo: presentation.slides.some(slide => 
          slide.layers.some(layer => layer.type === 'video')
        ),
      }
    };

    // Optionally exclude generation history to reduce file size
    if (!includeHistory) {
      delete (backupData as any).generationHistory;
      delete (backupData as any).sources;
    }

    // Convert to JSON with formatting
    const jsonContent = JSON.stringify(backupData, null, 2);
    
    // Create blob and download
    const blob = new Blob([jsonContent], { type: 'application/json' });
    const filename = generateFilename(presentation, 'json');
    saveAs(blob, filename);

    return createSuccessResult(filename, 'json');
  } catch (error) {
    console.error('Project backup export error:', error);
    return createErrorResult(error);
  }
};

/**
 * Validate project file before import
 */
export const validateProjectFile = async (file: File): Promise<{
  valid: boolean;
  errors: string[];
  warnings: string[];
  info?: {
    title?: string;
    slideCount?: number;
    fileFormatVersion?: string;
    createdWith?: string;
    fileSize: number;
  };
}> => {
  const errors: string[] = [];
  const warnings: string[] = [];

  try {
    if (!file) {
      errors.push('No file provided');
      return { valid: false, errors, warnings };
    }

    if (file.type !== 'application/json') {
      errors.push('Invalid file type. Expected JSON file.');
      return { valid: false, errors, warnings };
    }


    if (file.size === 0) {
      errors.push('File is empty.');
      return { valid: false, errors, warnings };
    }

    // Read and parse file
    const content = await new Promise<string>((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        if (e.target?.result) {
          resolve(e.target.result as string);
        } else {
          reject(new Error('Failed to read file'));
        }
      };
      reader.onerror = () => reject(new Error('Error reading file'));
      reader.readAsText(file);
    });

    let data: any;
    try {
      data = JSON.parse(content);
    } catch (parseError) {
      errors.push('Invalid JSON format. The file appears to be corrupted.');
      return { valid: false, errors, warnings };
    }

    // Basic structure validation
    if (!data || typeof data !== 'object') {
      errors.push('Invalid file structure.');
      return { valid: false, errors, warnings };
    }

    if (!data.slides || !Array.isArray(data.slides)) {
      errors.push('No valid slides found in the file.');
      return { valid: false, errors, warnings };
    }

    if (data.slides.length === 0) {
      warnings.push('The presentation has no slides.');
    }

    // Check compatibility
    const compatibilityCheck = checkImportCompatibility(data);
    if (!compatibilityCheck.compatible) {
      if (compatibilityCheck.canUpgrade) {
        warnings.push(`File format is outdated but can be upgraded: ${compatibilityCheck.reason}`);
      } else {
        errors.push(`Incompatible file format: ${compatibilityCheck.reason}`);
        return { valid: false, errors, warnings };
      }
    }

    // Gather file info
    const info = {
      title: data.title,
      slideCount: data.slides.length,
      fileFormatVersion: data.fileFormatVersion || data.version,
      createdWith: data.createdWith || data.exportedWith,
      fileSize: file.size
    };

    return {
      valid: errors.length === 0,
      errors,
      warnings,
      info
    };

  } catch (error) {
    errors.push(error instanceof Error ? error.message : 'Unknown validation error');
    return { valid: false, errors, warnings };
  }
};