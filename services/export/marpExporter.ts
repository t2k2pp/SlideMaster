import { Presentation, ExportResult } from '../../types';
import { saveAs } from 'file-saver';
import JSZip from 'jszip';
import {
  generateFilename,
  createErrorResult,
  createSuccessResult,
  validatePresentation
} from './exportUtils';

// =================================================================
// Marp Export Service - Marp Markdown format export
// =================================================================

/**
 * Export presentation as Marp Markdown format
 */
export const exportAsMarp = async (presentation: Presentation, includeImages: boolean = false): Promise<ExportResult> => {
  try {
    validatePresentation(presentation);

    // Determine Marp theme based on presentation theme
    let marpTheme = 'default';
    switch (presentation.theme) {
      case 'professional':
        marpTheme = 'default';
        break;
      case 'creative':
        marpTheme = 'gaia';
        break;
      case 'minimalist':
        marpTheme = 'uncover';
        break;
      case 'playful':
        marpTheme = 'gaia';
        break;
      default:
        marpTheme = 'default';
    }

    // Convert presentation to Marp markdown format
    let marpContent = `---
marp: true
theme: ${marpTheme}
paginate: true
size: ${presentation.slides[0]?.aspectRatio === '4:3' ? '4:3' : '16:9'}
title: "${presentation.title}"
description: "${presentation.description}"
author: SlideMaster
math: katex
---

<!-- _class: title -->

# ${presentation.title}

## ${presentation.description}

*Generated by SlideMaster*

---

`;

    // Process each slide
    presentation.slides.forEach((slide, index) => {
      // Determine slide layout based on content
      const hasImage = slide.layers.some(layer => layer.type === 'image');
      const textLayers = slide.layers.filter(layer => layer.type === 'text');
      
      // Add slide header if not first slide
      if (index > 0) {
        marpContent += `<!-- _header: '${slide.title}' -->\n\n`;
      }
      
      // Add slide title
      if (index === 0) {
        // Title slide already handled above
        return;
      } else {
        marpContent += `# ${slide.title}\n\n`;
      }
      
      // Process layers by type and position
      const sortedLayers = slide.layers.sort((a, b) => a.zIndex - b.zIndex);
      
      sortedLayers.forEach(layer => {
        if (layer.type === 'text') {
          const textLayer = layer as any;
          let content = textLayer.content;
          
          if (content && content.trim()) {
            // Preserve markdown formatting
            // Handle different text sizes
            const fontSize = textLayer.fontSize || 24;
            if (fontSize > 60) {
              content = `## ${content}`;
            } else if (fontSize > 40) {
              content = `### ${content}`;
            }
            
            // Handle alignment
            if (textLayer.textAlign === 'center') {
              content = `<div style="text-align: center">\n\n${content}\n\n</div>`;
            } else if (textLayer.textAlign === 'right') {
              content = `<div style="text-align: right">\n\n${content}\n\n</div>`;
            }
            
            marpContent += `${content}\n\n`;
          }
        } else if (layer.type === 'image') {
          const imageLayer = layer as any;
          
          if (imageLayer.src && imageLayer.src.startsWith('data:image/')) {
            // Track image for later export
            const altText = imageLayer.prompt || 'Generated Image';
            
            if (includeImages) {
              // Reference the image that will be included in the ZIP
              const imageFilename = `slide-${index + 1}-image-${presentation.slides[index].layers.filter(l => l.type === 'image' && l === layer).length}.png`;
              marpContent += `![${altText}](./images/${imageFilename})\n\n`;
            } else {
              // Provide instructions for manual image export
              marpContent += `<!-- 🖼️ Image: ${altText} -->\n`;
              marpContent += `<!-- TODO: Save the generated image as a file and reference it here -->\n`;
              marpContent += `<!-- ![${altText}](./images/slide-${index + 1}-image.png) -->\n\n`;
              marpContent += `> **📸 Image**: ${altText}\n`;
              marpContent += `> *Note: Export the image separately and place it in an 'images' folder*\n\n`;
            }
          } else if (imageLayer.prompt) {
            // Add image placeholder with instructions
            marpContent += `<!-- 🖼️ Image prompt: ${imageLayer.prompt} -->\n`;
            if (!includeImages) {
              marpContent += `<!-- Generate image and save as: ./images/slide-${index + 1}-image.png -->\n`;
              marpContent += `<!-- ![Image](./images/slide-${index + 1}-image.png) -->\n\n`;
            }
            marpContent += `> **🎨 Image to generate**: ${imageLayer.prompt}\n\n`;
          }
        } else if (layer.type === 'shape') {
          // Add comment for shapes
          marpContent += `<!-- 🔹 Shape element (not supported in Marp) -->\n\n`;
        }
      });
      
      // Add speaker notes if present
      if (slide.notes && slide.notes.trim()) {
        marpContent += `<!--\n📝 Speaker Notes:\n${slide.notes}\n-->\n\n`;
      }
      
      // Add slide separator (except for last slide)
      if (index < presentation.slides.length - 1) {
        marpContent += `---\n\n`;
      }
    });

    // Add footer with metadata and instructions
    marpContent += `\n---\n\n`;
    marpContent += `## 📝 Marp Export Notes\n\n`;
    marpContent += `This presentation was exported from SlideMaster to Marp format.\n\n`;
    marpContent += `### 🖼️ Images\n\n`;
    marpContent += `- Images are not directly embedded to keep file size manageable\n`;
    marpContent += `- Look for commented image references: \`<!-- ![Image](...) -->\`\n`;
    marpContent += `- Create an \`images\` folder next to this markdown file\n`;
    marpContent += `- Export images separately from SlideMaster (PNG format)\n`;
    marpContent += `- Uncomment and update image paths as needed\n\n`;
    marpContent += `### 🎨 How to use\n\n`;
    marpContent += `1. Install Marp CLI: \`npm install -g @marp-team/marp-cli\`\n`;
    marpContent += `2. Generate presentation: \`marp ${generateFilename(presentation, 'md').replace(/.*[\/\\]/, '')}\`\n`;
    marpContent += `3. Or use Marp for VS Code extension\n\n`;
    marpContent += `*Generated by SlideMaster on ${new Date().toLocaleString()}*`;

    if (includeImages) {
      // Create ZIP with Marp file and images
      const zip = new JSZip();
      
      // Add the Marp markdown file
      const markdownFilename = generateFilename(presentation, 'md').replace(/.*[\/\\]/, '');
      zip.file(markdownFilename, marpContent);
      
      // Create images folder and add images
      const imagesFolder = zip.folder('images');
      let imageIndex = 0;
      
      for (let slideIndex = 0; slideIndex < presentation.slides.length; slideIndex++) {
        const slide = presentation.slides[slideIndex];
        const imageLayers = slide.layers.filter(layer => layer.type === 'image');
        
        for (const layer of imageLayers) {
          const imageLayer = layer as any;
          if (imageLayer.src && imageLayer.src.startsWith('data:image/')) {
            // Extract base64 data and convert to blob
            const [, mimeType, base64Data] = imageLayer.src.match(/data:([^;]+);base64,(.+)/) || [];
            if (base64Data) {
              const byteCharacters = atob(base64Data);
              const byteNumbers = new Array(byteCharacters.length);
              for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
              }
              const byteArray = new Uint8Array(byteNumbers);
              const imageBlob = new Blob([byteArray], { type: mimeType });
              
              const imageFilename = `slide-${slideIndex + 1}-image-${imageIndex + 1}.png`;
              imagesFolder?.file(imageFilename, imageBlob);
              imageIndex++;
            }
          }
        }
      }
      
      // Generate ZIP and download
      const zipBlob = await zip.generateAsync({ type: 'blob' });
      const zipFilename = generateFilename(presentation, 'zip').replace('.zip', '-marp.zip');
      saveAs(zipBlob, zipFilename);
      
      return createSuccessResult(zipFilename, 'marp-zip');
    } else {
      // Regular Marp markdown export
      const blob = new Blob([marpContent], { type: 'text/markdown;charset=utf-8' });
      const filename = generateFilename(presentation, 'md');
      saveAs(blob, filename);

      return createSuccessResult(filename, 'marp');
    }
  } catch (error) {
    console.error('Marp export error:', error);
    return createErrorResult(error);
  }
};